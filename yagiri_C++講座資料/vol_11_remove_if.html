<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="github_hu.css" type="text/css" />
</head>
<body>
<h1 id="c講座資料-vol_11">C++講座資料 vol_11</h1>
<p>vectorはコンテナの一種である。コンテナに対してソートや削除を行うアルゴリズムというものがある。 （一般に言うアルゴリズムではない）<br />今回はアルゴリズムに関して扱う。</p>
<h2 id="ソート-stdsort">ソート std::sort</h2>
<p>std::sortを使うと、コンテナの中身を小さい順にソートすることができる。このソート関数の中身はC++の中の人が作ったものなので、とても高速である。<br />アルゴリズムを使うには、algorithmヘッダーをインクルードする。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="dt">int</span> main(){
    std::vector&lt;<span class="dt">int</span>&gt; vec;
    
    <span class="co">//適当な数を10個入れる</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++){
        vec.push_back(rand()%<span class="dv">30</span>);
    }

    <span class="co">//表示</span>
    <span class="kw">for</span>(<span class="kw">auto</span> i = vec.begin(); i &lt; vec.end(); ++i){
        std::cout &lt;&lt; *i &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; std::endl;

    <span class="co">//ソート</span>
    std::sort(vec.begin(), vec.end());

    <span class="co">//表示</span>
    <span class="kw">for</span>(<span class="kw">auto</span> i = vec.begin(); i &lt; vec.end(); ++i){
        std::cout &lt;&lt; *i &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="要素を削除-stdremove_if">要素を削除 std::remove_if</h2>
<p>remove_ifは条件にあった要素を削除する。<br />正確には、条件にあった要素を、vectorの後ろに配置しなおし、削除したように見せかけた後のvectorの最後のイテレータを返す。 つまり、remove_if関数を呼んだだけでは要素は削除されておらず、その後にerase関数を呼ぶ必要がある。</p>
<p>//remove_ifを実行し、条件にあった要素を後ろに詰める。 auto rmviter = std::remove_if(vec.begin(),vec.end(), 関数ポインタ);</p>
<p>//後ろの方に詰められた要素を削除 vec.erase( rmviter, vec.end() );</p>
<p>remove_ifの第一引数には削除するかを判定する範囲の先頭、第二引数には終端を書く。 remove_ifの第三引数には削除の条件を返す関数の名前を書く。（正確には関数ポインタ）</p>
<blockquote>
<p>3の倍数を削除する例</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="co">//3の倍数かどうかをたしかめて返す叙述関数</span>
<span class="dt">bool</span> isMultipleThree(<span class="dt">int</span> x){
    <span class="kw">return</span> (x%<span class="dv">3</span>) == <span class="dv">0</span>;
}

<span class="dt">int</span> main(){

    std::vector&lt;<span class="dt">int</span>&gt; vec;<span class="co">//int型の動的配列</span>

    <span class="co">//0から数を入れる</span>
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++){
        vec.push_back(i);
    }

    <span class="co">//表示</span>
    <span class="kw">for</span>(<span class="kw">auto</span> i = vec.begin(); i &lt; vec.end(); ++i){
        std::cout &lt;&lt; *i &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; std::endl;


    <span class="co">//vecの中から3の倍数を後ろに詰める</span>
    <span class="co">//3の倍数かどうかの判定は3番目のパラメータで渡された関数ポインタで判定</span>
    <span class="kw">auto</span> rmviter = std::remove_if(vec.begin(), vec.end(), isMultipleThree);

    <span class="co">//実際に削除</span>
    vec.erase( rmviter, vec.end() );

    <span class="co">//表示</span>
    <span class="kw">for</span>(<span class="kw">auto</span> i = vec.begin(); i &lt; vec.end(); ++i){
        std::cout &lt;&lt; *i &lt;&lt; <span class="st">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<blockquote>
<p>remove_ifの第三引数には、remove_ifが対象にするvectorの中身を引数に取り、bool型(trueかfalse)を返す関数を入れる。以下が例。</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> func(配列の要素の型 x){
    <span class="kw">return</span> (x%<span class="dv">3</span>) == <span class="dv">0</span>;<span class="co">//条件に一致してるか確認してbool型を返す</span>
}</code></pre>
<h2 id="演習問題">演習問題</h2>
<ol style="list-style-type: decimal">
<li>以下のようなクラスを定義した。myclassのvectorを用意し、適当な値のa(0~10ぐらい)を持ったデータを10個格納し、aが5以下の要素をremove_ifを用いて削除せよ。</li>
</ol>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> myclass{
<span class="kw">public</span>:
    <span class="dt">int</span> a;

    myclass(<span class="dt">int</span> aa):
        a(aa)
    {
    }
};</code></pre>
</body>
</html>
