<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="github_hu.css" type="text/css" />
</head>
<body>
<h1 id="cpp講座資料vol_7">cpp講座資料　vol_7</h1>
<p>実際にゲームを作る時、ファイル分けをすることが必要になる。<br />今回はクラスの内容を.hと.cppに分け、それが必要なケースと、なぜ必要になるのかを解説する。<br />若干ややこしい話になるので、指示をよく聞き、指示通りにファイルの位置を配置すること。</p>
<h2 id="ファイル分け">ファイル分け</h2>
<p>以下のように、.hと.cppにクラスの定義を分けて書くことが出来る。<br />.cppには、クラス名::関数名と書く必要がある。</p>
<blockquote>
<p>player.h</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">class</span> player{
<span class="kw">public</span>: 
    <span class="dt">int</span> x, y;

    player(<span class="dt">int</span> xx, <span class="dt">int</span> yy);

    <span class="dt">void</span> update();

    <span class="dt">void</span> draw();

    <span class="dt">void</span> show_xy();
};</code></pre>
<blockquote>
<p>player.cpp</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;player.h&quot;</span>

player::player(<span class="dt">int</span> xx, <span class="dt">int</span> yy) :
x(xx),
y(yy)
{
}

<span class="dt">void</span> player::update(){
    std::cout &lt;&lt; <span class="st">&quot;playerのupdateが呼ばれました。&quot;</span> &lt;&lt; std::endl;
}

<span class="dt">void</span> player::draw(){
    std::cout &lt;&lt; <span class="st">&quot;playerのdrawが呼ばれました。&quot;</span> &lt;&lt; std::endl;
}

<span class="dt">void</span> player::show_xy(){
    std::cout &lt;&lt; <span class="st">&quot;playerのshow_xyが呼ばれました。 x:&quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot; y:&quot;</span> &lt;&lt; y &lt;&lt; std::endl;
}</code></pre>
<blockquote>
<p>main.cpp</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;player.h&quot;</span>

<span class="dt">int</span> main(<span class="dt">void</span>){

    player ply(<span class="dv">20</span>, <span class="dv">30</span>);

    ply.update();

    ply.draw();

    ply.show_xy();

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="コンポジション">コンポジション</h2>
<p>クラスをクラスのメンバにすることが出来る。<br />以下の例では、pointクラスをまず定義し、playerクラスでpointクラスのメンバを持っている。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">class</span> point{
<span class="kw">public</span>:
    <span class="dt">int</span> x, y;
    point(<span class="dt">int</span> xx, <span class="dt">int</span> yy) :
        x(xx),
        y(yy)
    {
    }
};

<span class="kw">class</span> player{
<span class="kw">public</span>:
    point pt;
    <span class="dt">int</span> hp;

    player(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> hp_) :
        pt(x, y),
        hp(hp_)
    {
    }
};


<span class="dt">int</span> main(<span class="dt">void</span>){
    player ply(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">64</span>);

    std::cout &lt;&lt; <span class="st">&quot;x:&quot;</span> &lt;&lt; ply.pt.x &lt;&lt; <span class="st">&quot;, y:&quot;</span> &lt;&lt; ply.pt.y &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="st">&quot;hp:&quot;</span> &lt;&lt; ply.hp &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>コンストラクタは以下のように書く。引数を受け渡すと考えれば良い。<br />classAがclassBを持つ場合</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">classA(引数1,引数2,引数3...) :
    classB(引数1,引数2,引数3...)
    {
    }</code></pre>
<p>クラスをコンポジションした場合、クラスに含まれているクラスのコンストラクタが先に呼ばれる。デストラクタは逆の順で呼ばれる。<br />hogeやpiyoは日本では、「特に意味のない名前」を表す。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">class</span> hoge{
<span class="kw">public</span>:
    <span class="dt">int</span> x;

    hoge(<span class="dt">int</span> xx):
        x(xx)
    {
        std::cout &lt;&lt; <span class="st">&quot;hogeのコンストラクタが呼ばれました&quot;</span> &lt;&lt; std::endl;
    }

    ~hoge(){
        std::cout &lt;&lt; <span class="st">&quot;hogeのデストラクタが呼ばれました&quot;</span> &lt;&lt; std::endl;
    }
};

<span class="kw">class</span> piyo{
<span class="kw">public</span>:
    hoge hoge_;
    <span class="dt">int</span> y;

    piyo(<span class="dt">int</span> xx, <span class="dt">int</span> yy):
        hoge_(xx),
        y(yy)
    {
        std::cout &lt;&lt; <span class="st">&quot;piyoのコンストラクタが呼ばれました&quot;</span> &lt;&lt; std::endl;
    }

    ~piyo(){
        std::cout &lt;&lt; <span class="st">&quot;piyoのデストラクタが呼ばれました&quot;</span> &lt;&lt; std::endl;
    }
};


<span class="dt">int</span> main(<span class="dt">void</span>){

    piyo piyo_(<span class="dv">100</span>, <span class="dv">200</span>);

    std::cout &lt;&lt; piyo_.hoge_.x &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; piyo_.y &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="インクルード">インクルード</h2>
<p>#includeを使うと自分が定義したヘッダーをインクルードできる。インクルードすると、その部分にヘッダーの中身のコードが展開される。</p>
<h2 id="pragma-once">#pragma once</h2>
<p>#pragma onceを使うと一度読み込まれたヘッダーは読み込まれないようになる。複数のファイルから読み込まれるヘッダーの一番上につけることで、多重定義を防ぐことが出来る。<br />以下の例では、playerクラスとenemyクラスで共通で使うpointクラスを作り、それをどちらのファイルからも読み込んでいる。<br />pointクラスのpragma onceを外すと、コンパイルエラーが起きる。</p>
<blockquote>
<p>point.h</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#pragma once</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">class</span> point{
<span class="kw">public</span>:
    <span class="dt">int</span> x, y;
    point(<span class="dt">int</span> xx, <span class="dt">int</span> yy) :
        x(xx),
        y(yy)
    {
    }
};</code></pre>
<blockquote>
<p>enemy.h</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;point.h&quot;</span>

<span class="kw">class</span> enemy{
<span class="kw">public</span>:
    point pt;

    enemy(<span class="dt">int</span> x, <span class="dt">int</span> y) :
        pt(x, y)
    {
    }
};</code></pre>
<blockquote>
<p>player.h</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;point.h&quot;</span>

<span class="kw">class</span> player{
<span class="kw">public</span>:
    point pt;

    player(<span class="dt">int</span> x, <span class="dt">int</span> y) :
        pt(x, y)
    {
    }
};</code></pre>
<blockquote>
<p>main関数内</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;player.h&quot;</span>
<span class="ot">#include &quot;enemy.h&quot;</span>


<span class="dt">int</span> main(<span class="dt">void</span>){

    player ply(<span class="dv">100</span>, <span class="dv">200</span>);
    enemy emy(<span class="dv">300</span>, <span class="dv">400</span>);

    std::cout &lt;&lt; ply.pt.x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; ply.pt.y &lt;&lt; std::endl;
    std::cout &lt;&lt; emy.pt.x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; emy.pt.y &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>クラスが他のクラスを実体としてメンバとして持つ、または他のクラスのメンバにアクセスするときは、他のクラスの定義がクラスの前方（コードの上のほう）になければならない。　　</li>
<li>実際にゲームを作るときは、とりあえず#pragma onceをつけよう。#pragma onceは特に害はない。</li>
</ul>
<h2 id="gamemanagerクラス">GameManagerクラス</h2>
<p>実際ゲームを作る時、playerやenemyの配列、bulletの配列、effectの配列等をメンバに持ち、それらを管理するmanagerクラスを作ると便利である。<br />今回は、managerクラスをシングルトンにすることで、enemyがplayerにアクセスしたいときに、managerクラスを介してplayerクラスにアクセス出来るようにしたい。また、同様にplayerクラスがenemyクラスにアクセス出来るようにしたい。<br />(前回は、enemyクラスがplayerへのポインタを持つことで、playerクラスにアクセスすることができたが、今回はenemyクラスがplayerクラスへのポインタを持つ必要はない)　　 playerがenemyの情報に、enemyがplayerの情報に相互にアクセス出来るようにするため、上手くファイルをインクルードしなければならない。<br />以下の例では、playerはshowenemyx関数でenemyのxにアクセスし、enemyはshowplayerx関数でplayerのxにアクセスしている。</p>
<blockquote>
<p>player.h</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#pragma once</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;manager.h&quot;</span>

<span class="kw">class</span> player{
<span class="kw">public</span>:
    <span class="dt">int</span> x;

    player(<span class="dt">int</span> xx);
    <span class="dt">void</span> update();
    <span class="dt">void</span> showenemyx();

};</code></pre>
<blockquote>
<p>player.cpp</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;manager.h&quot;</span>

player::player(<span class="dt">int</span> xx) :
x(xx)
{
}

<span class="dt">void</span> player::update(){
    std::cout &lt;&lt; <span class="st">&quot;player内のupdateが呼ばれました。xは:&quot;</span> &lt;&lt; x &lt;&lt; std::endl;
}

<span class="dt">void</span> player::showenemyx(){
    std::cout &lt;&lt; <span class="st">&quot;player内のshowenemyxが呼ばれました。&quot;</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="st">&quot;enemyのxは：&quot;</span> &lt;&lt; manager::get().enemy_.x &lt;&lt; std::endl;
}</code></pre>
<blockquote>
<p>enemy.h</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#pragma once</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;manager.h&quot;</span>

<span class="kw">class</span> enemy{
<span class="kw">public</span>:
    <span class="dt">int</span> x;

    enemy(<span class="dt">int</span> xx);
    <span class="dt">void</span> update();
    <span class="dt">void</span> showplayerx();

};</code></pre>
<blockquote>
<p>enemy.cpp</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;manager.h&quot;</span>

enemy::enemy(<span class="dt">int</span> xx) :
x(xx)
{
}

<span class="dt">void</span> enemy::update(){
    std::cout &lt;&lt; <span class="st">&quot;enemy内のupdateが呼ばれました。xは:&quot;</span> &lt;&lt; x &lt;&lt; std::endl;
}

<span class="dt">void</span> enemy::showplayerx(){
    std::cout &lt;&lt; <span class="st">&quot;enemy内のshowplayerxが呼ばれました。&quot;</span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="st">&quot;playerのxは：&quot;</span> &lt;&lt; manager::get().player_.x &lt;&lt; std::endl;
}</code></pre>
<blockquote>
<p>manager.h</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#pragma once</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;player.h&quot;</span>
<span class="ot">#include &quot;enemy.h&quot;</span>

<span class="kw">class</span> manager{
<span class="kw">public</span>:
    <span class="dt">static</span> manager&amp; get(){
        <span class="dt">static</span> manager inst;
        <span class="kw">return</span> inst;
    }
    
    manager(<span class="dt">const</span> manager&amp; r) = <span class="kw">delete</span>;<span class="co">//コピー禁止</span>
    manager&amp; <span class="kw">operator</span>=(<span class="dt">const</span> manager&amp; r) = <span class="kw">delete</span>;<span class="co">//代入禁止</span>
    
    player player_;
    enemy enemy_;


<span class="kw">private</span>:
    manager() :
        player_(<span class="dv">100</span>),
        enemy_(<span class="dv">200</span>)
    {
    };
};</code></pre>
<blockquote>
<p>main.cpp</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &quot;manager.h&quot;</span>

<span class="dt">int</span> main(){

    manager::get().player_.update();
    manager::get().enemy_.update();

    manager::get().player_.showenemyx();
    manager::get().enemy_.showplayerx();

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="演習問題">演習問題</h2>
<ul>
<li>上記のplayerクラスのx, enemyクラスのxはpublicメンバで、直接書き換えることが可能であり、危険である。<br />この2つをprivateメンバにし、外から値が取得できるようにgetx()関数を実装せよ。</li>
</ul>
<h2 id="演習問題dxライブラリ">演習問題(DXライブラリ)</h2>
<ul>
<li>GameManagerクラスを作れ。<br />GameManagerクラスは、playerやenemymanagerをメンバに持ち、それらを管理するクラスである。<br />GameManagerをシングルトンにすることで、GameManagerを介してplayerやenemyの情報にアクセスできるようにせよ。<br />GameManagerクラスのupdateを呼べば、playerとすべてのenemyのupdateが呼ばれるようにせよ。<br />enemyクラスがplayerクラスへのポインタを持っていた場合、それを消して、playerクラスへのアクセスはGameManagerクラスを介して行うようにせよ。</li>
</ul>
</body>
</html>
