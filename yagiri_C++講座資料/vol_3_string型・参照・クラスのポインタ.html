<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="github_hu.css" type="text/css" />
</head>
<body>
<h1 id="c講座資料-vol_3">C++講座資料 vol_3</h1>
<h2 id="string型">string型</h2>
<p>C++標準ライブラリのstring型を使うと、Cのchar型に比べ、より簡単に文字列を扱うことが出来る。 +演算子で文字列の結合、==演算子で文字列の比較が出来る。<br />string型を使用するときは、stringヘッダーをインクルードする。（string.hではないことに注意）</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main(){
    std::string str1 = <span class="st">&quot;いかろちゃん&quot;</span>;
    std::string str2 = <span class="st">&quot;かわいい&quot;</span>;
    
    std::cout &lt;&lt; str1 &lt;&lt; std::endl;
    std::cout &lt;&lt; str2 &lt;&lt; std::endl;
    
    std::string str3;
    <span class="co">// +で文字列の結合ができる</span>
    str3 = str1 + str2;
    
    std::cout &lt;&lt; str3 &lt;&lt; std::endl;
    
    <span class="co">// ==で文字列の比較ができる trueなので1が出力される</span>
    std::cout &lt;&lt; (str3 == (str1+str2)) &lt;&lt; std::endl;
    
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<blockquote>
<p>std::to_string関数を使うと、int型、double型等の変数をstring型に変換できる。</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main(){
    std::string str = <span class="st">&quot;いかろちゃんかわいい&quot;</span>;
    <span class="dt">int</span> ix = <span class="dv">23</span>;
    <span class="dt">double</span> dx = <span class="fl">3.</span><span class="dv">14</span>;
    
    str += <span class="st">&quot; &quot;</span>;
    str += std::to_string(ix);
    str += <span class="st">&quot; &quot;</span>;
    str += std::to_string(dx);
    
    std::cout &lt;&lt; str &lt;&lt; std::endl;
    
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="bool型">bool型</h2>
<p>C言語では、0は偽、それ以外は真だったが、C++には真偽を表すためだけの型、bool型が存在する。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>){

    <span class="dt">bool</span> b = <span class="kw">true</span>;

    <span class="kw">if</span> (b){
        std::cout &lt;&lt; <span class="st">&quot;条件文は真&quot;</span> &lt;&lt; std::endl;
    }
    <span class="kw">else</span>{
        std::cout &lt;&lt; <span class="st">&quot;条件文は偽&quot;</span> &lt;&lt; std::endl;
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>以下のように、条件を満たすかどうかの真・偽を返す関数の返り値の型としてbool型を使うことが多い。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">bool</span> iseven(<span class="dt">int</span> num){
    <span class="kw">return</span> (num % <span class="dv">2</span>) == <span class="dv">0</span>;
}

<span class="dt">int</span> main(<span class="dt">void</span>){

    <span class="kw">if</span> (iseven(<span class="dv">10</span>)){
        std::cout &lt;&lt; <span class="st">&quot;条件文は真&quot;</span> &lt;&lt; std::endl;
    }
    <span class="kw">else</span>{
        std::cout &lt;&lt; <span class="st">&quot;条件文は偽&quot;</span> &lt;&lt; std::endl;
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}   </code></pre>
<h2 id="スコープ">スコープ</h2>
<p>{ } で囲まれた部分を抜けると、その{}内部で宣言された変数は破棄されるので、アクセスできなくなる。 変数や関数の「見える」範囲をスコープと言い、変数の寿命はスコープによって決まる。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">void</span> func(){
    <span class="dt">int</span> a = <span class="dv">10</span>;
    std::cout &lt;&lt; <span class="st">&quot;aの値は &quot;</span> &lt;&lt; a &lt;&lt; std::endl;
}

<span class="dt">int</span> main(){
    
    func();

    <span class="co">//コメントを外すとコンパイルエラー</span>
    <span class="co">//a = 100;  </span>

    <span class="kw">if</span>(<span class="kw">true</span>){
        <span class="dt">int</span> b = <span class="dv">20</span>;
        std::cout &lt;&lt; <span class="st">&quot;bの値は &quot;</span> &lt;&lt; b &lt;&lt; std::endl;
    }
    
    <span class="co">//コメントを外すとコンパイルエラー</span>
    <span class="co">//b = 100; </span>

    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++){
        std::cout &lt;&lt; <span class="st">&quot;iの値は &quot;</span> &lt;&lt; i &lt;&lt; std::endl;
    }
    
    <span class="co">//コメントを外すとコンパイルエラー</span>
    <span class="co">//i = 100; </span>

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<blockquote>
<p>{}だけでもスコープを作ることができる</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main(){
    {
        <span class="dt">int</span> b = <span class="dv">20</span>;
        std::cout &lt;&lt; <span class="st">&quot;bの値は &quot;</span> &lt;&lt; b &lt;&lt; std::endl;
    }
    
    <span class="co">//コメントを外すとコンパイルエラー</span>
    <span class="co">//b = 100; </span>

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="参照">参照</h2>
<p>swap関数を実装するためにポインタを用いる事があったかもしれない。 C++ではそれを扱いやすくした参照(リファレンス)というものが存在する。</p>
<blockquote>
<p>ポインタを用いたaとbを入れ替える関数</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="co">//aとbを入れ替える関数 </span>
<span class="dt">void</span> swap(<span class="dt">int</span> *a,<span class="dt">int</span> *b){
    <span class="dt">int</span> tmp=*a;
    *a=*b;
    *b=tmp;
    <span class="kw">return</span>;
}

<span class="dt">int</span> main(){
 
    <span class="dt">int</span> a=<span class="dv">3</span>;
    <span class="dt">int</span> b=<span class="dv">5</span>;
 
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; std::endl;
    
    swap(&amp;a, &amp;b);<span class="co">//aとbのポインタを渡さなければいけない</span>
    
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; std::endl;
 
    <span class="kw">return</span> <span class="dv">0</span>;
}  </code></pre>
<blockquote>
<p>よくない例。下のように書くと、関数内でaとbのコピーが出来て、コピーのaとbが入れ替えられ、関数を抜けた時点で破棄されるので、main関数内のaとbは入れ替えられない。</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="co">//aとbを入れ替える関数 値渡しなので入れ替えられない</span>
<span class="dt">void</span> swap(<span class="dt">int</span> a,<span class="dt">int</span> b){
    <span class="dt">int</span> tmp=a;
    a=b;
    b=tmp;
    <span class="kw">return</span>;
}

<span class="dt">int</span> main(){

    <span class="dt">int</span> a=<span class="dv">3</span>;
    <span class="dt">int</span> b=<span class="dv">5</span>;
 
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; std::endl;
    
    swap(a, b);
    
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; std::endl;
    
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<blockquote>
<p>参照を用いたaとbを入れ替える関数</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="co">//aとbを入れ替える関数</span>
<span class="dt">void</span> swap(<span class="dt">int</span>&amp; a,<span class="dt">int</span>&amp; b){
    <span class="dt">int</span> tmp=a;
    a=b;
    b=tmp;
    <span class="kw">return</span>;
}

<span class="dt">int</span> main(){
 
    <span class="dt">int</span> a=<span class="dv">3</span>;
    <span class="dt">int</span> b=<span class="dv">5</span>;
 
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; std::endl;
    
    swap(a, b);
    
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; std::endl;
 
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<blockquote>
<p>参照を用いてhogeに別名をつけることが出来る。</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main(){
 
    <span class="dt">int</span> hoge = <span class="dv">2</span>;
 
    <span class="co">//aliasはhogeの別名(aliasを操作するとhogeの値が変わる)</span>
    <span class="dt">int</span>&amp; alias = hoge;
    
    std::cout &lt;&lt; hoge &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; alias &lt;&lt; std::endl;
    
    alias=<span class="dv">4</span>;
    std::cout &lt;&lt; hoge &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; alias &lt;&lt; std::endl;
 
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<blockquote>
<p>ポインタを使っても同じことが出来るが、*や&amp;をつけるのに手間がかかり、ミスをしてバグを起こしやすいので、これからは参照を使おう。</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main(){
 
    <span class="dt">int</span> hoge = <span class="dv">2</span>;
 
    <span class="dt">int</span>* ptr = &amp;hoge;
    
    std::cout &lt;&lt; hoge &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;
    
    *ptr = <span class="dv">4</span>;
    std::cout &lt;&lt; hoge &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;
 
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="演習問題">演習問題</h2>
<ol style="list-style-type: decimal">
<li><p>文字列をうけとりその末尾に「その点トッポってすげぇよな、最後までチョコたっぷりだもん。」と付加するような関数を作れ。</p></li>
<li><p>空の文字列を用意し、入力された文字をその文字列の終端に付け加えていき、&quot;show&quot;と入力されたら現在の文字列を表示せよ。</p></li>
</ol>
<h2 id="ポインタ復習">ポインタ（復習）</h2>
<blockquote>
<p>2通りの方法でaの値とアドレスを表示</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>){

    <span class="dt">int</span> a = <span class="dv">100</span>;
    <span class="dt">int</span> *ptr = &amp;a;

    <span class="co">//2通りの方法でaの値とアドレスを表示</span>
    std::cout &lt;&lt; <span class="st">&quot;aの値:&quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot;  aのアドレス:&quot;</span> &lt;&lt; &amp;a &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="st">&quot;aの値:&quot;</span> &lt;&lt;  *ptr &lt;&lt; <span class="st">&quot;  aのアドレス:&quot;</span> &lt;&lt; ptr &lt;&lt; std::endl &lt;&lt; std::endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="オブジェクトへのポインタ">オブジェクトへのポインタ</h2>
<p>オブジェクトを指すポインタからオブジェクトの要素にアクセスしたい時がある。<br />下の例では、オブジェクトを指すポインタ、ptrから、objのxにアクセスしたい。<br />(*ptr).xと書けばobjのxにアクセスできるが、少々書きづらいので、<br />ptr-&gt;xと書くことができるようになっている。<br />(*ptr).x と ptr-&gt;x は同じ意味である。<br />-&gt; をアロー演算子という。</p>
<p>ちなみに、*ptr.xと書くと*(ptr.x)と解釈され、ptrのx（存在しない）が指すものを表す。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">class</span> point{
<span class="kw">public</span>:
    <span class="dt">int</span> x, y;

    point(<span class="dt">int</span> xx, <span class="dt">int</span> yy)
    {
        x = xx;
        y = yy;
    }
};

<span class="dt">int</span> main(<span class="dt">void</span>){

    point obj(<span class="dv">12</span>, <span class="dv">34</span>);
    point *ptr = &amp;obj;
    
    <span class="co">//普通に表示</span>
    std::cout &lt;&lt; obj.x &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; obj.y &lt;&lt; std::endl;

    std::cout &lt;&lt; (*ptr).x &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; (*ptr).y &lt;&lt; std::endl;

    std::cout &lt;&lt; ptr-&gt;x &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; ptr-&gt;y &lt;&lt; std::endl;


    <span class="co">//↓このようには書けない。　*(ptr.x)と解釈されるから</span>
    <span class="co">//std::cout &lt;&lt; *ptr.x &lt;&lt; &quot; &quot; &lt;&lt; *ptr.y &lt;&lt; std::endl;</span>

    
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="演習問題dxライブラリ">演習問題(DXライブラリ)</h2>
<p>（1. 2.…と順番に解いていって下さい。 これまでコードを書いてきたプロジェクトとは別に新しくプロジェクトを作ってください。）</p>
<ol style="list-style-type: decimal">
<li>string型の変数を用意し、DrawFormatStringToHandle関数を用いて画面中央に表示せよ。はじめの文字列は入力を求めるのではなく、プログラム内で決めてよい。</li>
</ol>
<ul>
<li><p>DrawFormatStringToHandle関数は引数にstring型ではなくchar*を取る。 (string型変数).c_str()関数を使うことでstring型の文字列をchar*へ変換できる。</p>
<blockquote>
<p>例</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp">string str = <span class="st">&quot;aaa&quot;</span>;
DrawFormatStringToHandle( x , y , Color , FontHandle , str.c_str() ) ;</code></pre></li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Xキーを押した時に、上記の文字列の末尾に「かわいい」が追加されるようにせよ。</p></li>
<li><p>以下の様なplayerクラスとenemyクラスを用意した。playerクラスとenemyクラスのインスタンスを作り、動作を確認せよ。</p></li>
</ol>
<blockquote>
<p>playerクラス</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> player{
<span class="kw">public</span>:
    <span class="dt">double</span> x, y;
    <span class="dt">double</span> movev;

    player(){
        x = <span class="dv">400</span>;
        y = <span class="dv">500</span>;
        movev = <span class="dv">3</span>;
    }

    <span class="dt">void</span> update(){
        <span class="kw">if</span>(CheckHitKey(KEY_INPUT_RIGHT) == <span class="dv">1</span>){
            x += movev;
        }
        <span class="kw">if</span>(CheckHitKey(KEY_INPUT_LEFT) == <span class="dv">1</span>){
            x -= movev;
        }
        <span class="kw">if</span>(CheckHitKey(KEY_INPUT_UP) == <span class="dv">1</span>){
            y -= movev;
        }
        <span class="kw">if</span>(CheckHitKey(KEY_INPUT_DOWN) == <span class="dv">1</span>){
            y += movev;
        }
    }

    <span class="dt">void</span> draw(){
        DrawCircle(x, y, <span class="dv">10</span>, GetColor(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>), <span class="dv">1</span>);
    }

};</code></pre>
<blockquote>
<p>enemyクラス</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> enemy{
<span class="kw">public</span>:
    <span class="dt">double</span> x, y, vx, vy;
    enemy(<span class="dt">double</span> ix, <span class="dt">double</span> iy){
        x = ix;
        y = iy;
        vx = <span class="dv">0</span>;
        vy = <span class="fl">1.</span><span class="dv">0</span>;
    }

    <span class="dt">void</span> update(){
        x += vx;
        y += vy;
    }

    <span class="dt">void</span> draw(){
        DrawCircle(x, y, <span class="dv">24</span>, GetColor(<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">1</span>);
    }

};</code></pre>
<ol style="list-style-type: decimal">
<li><p>player.hとenemy.hを作り、playerクラスとenemyクラスをファイル分けせよ。</p></li>
<li><p>enemyがplayerの方向に移動するようにしたい。enemyクラスが「playerクラスへのポインタ」をメンバに持つようにして、playerクラスとenemyクラスのインスタンスを生成した後にenemyのインスタンスににplayerのインスタンスのポインタを渡し、そのポインタからplayerクラスのx,yにアクセスすることでenemyがplayerの位置を取得し、その方向に移動できるようにせよ。<br />（今回は、敵の追尾は大まかで良い。例：playerのxがenemyのxより大きければenemyは右に、そうでなければ左に動く…など）</p></li>
</ol>
<blockquote>
<p>ヒント</p>
</blockquote>
<p>プログラムは、上から順にコンパイラに解釈されていく。enemyクラス内でplayerクラスにアクセスするには、アクセスする前にplayerクラスの中身をコンパイラが知らなければならない。<br />今回の場合、WinMainがあるcppの上部で、 #include &quot;player.h&quot; が #include &quot;enemy.h&quot; より前に書かれていれば、コンパイラがplayerの中身を知ってからenemy.hを解釈するので問題ない。<br />#include &quot;enemy.h&quot; を #include &quot;player.h&quot; より前に書きたいときは、enemy.hがインクルードされる前にどこかのヘッダー、またはenemy.hの上部に #include &quot;player.h&quot; があればよい。<br />enemy.hとmain.cppの二箇所からでplayer.hを読み込むときは、多重インクルードを防ぐため、player.hの上部に #pragma once をつける必要がある。</p>
<blockquote>
<p>enemy側</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> enemy{
<span class="kw">public</span>:
    <span class="dt">double</span> x, y, vx, vy;

    player* pplayer;<span class="co">//これを追加</span>

    <span class="co">//ポインタ取得用関数</span>
    <span class="dt">void</span> setplayerptr(player* ptr){
        pplayer = ptr;
    }

    <span class="co">//以下略</span>
};</code></pre>
<blockquote>
<p>初期化処理側</p>
</blockquote>
<pre class="sourceCode cpp"><code class="sourceCode cpp">player ply;<span class="co">//playerのインスタンスを生成</span>
enemy emy;<span class="co">//enemyのインスタンスを生成</span>
emy.setplayerptr(&amp;ply);<span class="co">//ポインタを入れる</span></code></pre>
</body>
</html>
